% CLF-CBF-QP geometric control of 3D-moving quadrotor
% by Guofan Wu (gwu)
% ------------------------------------------------
% load parameter from a .mat file
% include system's mass parameter
% include system's reference parameter
% ------------------------------------------------
% T: the time duration of simulation

%% Control using Control Barrier Function
function quad_3d_cbf_clf_qp(T)
    clc;
    close all;
    if nargin < 1
        T = 10;
    end

    load('prms.mat'); % generated by "prms_gen.m" file

    %% Simulation based on ODE function
    % control function handles
    ctrl_hdl1 = @Naive_Geometric_Control;
    ctrl_hdl2 = @Seq_CLF_CBF_QP;
    ctrl_hdl3 = @Seq_CLF_QP;
    current_hdl = ctrl_hdl3;
    ctrl_hdl_str = func2str(current_hdl);

    % initial condition of different trials
    % -------------------------------------------------
    % x(1:3): position
    % x(4:6): velocity
    % x(7:15): rotation matrix
    % x(16:18): body angular velocity
    % -------------------------------------------------
    % initial condition
    R0 = eye(3);
    y0 = [0; 2; 1.5; ...
        1; 0; 0; ...
        R0(:); ...
        0.2; 0.3; 1.0];

    % option of ode function
    options = odeset('RelTol', 1e-4, 'AbsTol', 1e-8);

    % simulation process
    disp('The simulation process has started.');
    disp(strcat('Controller: ', ctrl_hdl_str));
    disp('---------------------------------------------');
    tspan = [0, T];
    tic
    [t1, y1] = ode15s(@quad_3d_ode, tspan, y0, options, sys_prms, ref_prms, current_hdl);
    toc
    disp('---------------------------------------------');
    disp('The computation has completed. ');
    disp('Store necessary data now. ');
    % compute the corresponding control input and desired velocity at each time
    n = length(t1);
    F = zeros(4, n); % store thrust
    yd = zeros(18, n); % store reference

    for j = 1:n
        trajd = Flat2State(t1(j), sys_prms, ref_prms);
        yd(:, j) = struct2vec(trajd);
        uc = feval(current_hdl, t1(j), y1(j, :)', trajd, sys_prms);
        F(:, j) = uc;
    end
    
    figure;
    for i= 1:4
       subplot(2,2,i);
       plot(t1, F(i,:),'linewidth', 1); 
       grid on; grid minor;
    end

    % save all the data into .mat file
    data_file_name = strcat(ctrl_hdl_str, '_sim_data.mat');
    save(data_file_name);
    disp('Data successfully stored!');
end

%% Ode Function of this 3d-Moving Quadrotor
function [dy] = quad_3d_ode(t, y, sys_prms, ref_prms, ctrl_hdl)
    dy = zeros(18, 1);

    % convert the current state
    v = y(4:6);
    R = reshape(y(7:15), 3, 3);
    Omega = y(16:18);
    Omega_hat = hat(Omega);
    dR = R * Omega_hat;

    % get the current system's parameters
    m = sys_prms.m;
    J = sys_prms.J;
    g = sys_prms.g;
    e3 = [0; 0; 1];

    % get the current reference and control input
    trajd = Flat2State(t, sys_prms, ref_prms);
    u = feval(ctrl_hdl, t, y, trajd, sys_prms);
    % [f; M] where M is represented in body frame

    % update the system dynamics
    F = max(0, u(1)); % input saturation
    M = u(2:4);

    % translational and angular velocities
    dy(1:3) = v;
    dy(7:15) = dR(:);

    % translational and angular accelerations
    dy(4:6) = F * R * e3 / m - g * e3;
    dy(16:18) = J \ (M - Omega_hat * J * Omega);

    % -----------------------------------------------
    % check simulation time for stability property
    debug = 0;
    if debug == 1
        disp(['The current time is ', num2str(t)]);
    end
    % -----------------------------------------------
end

%% Naive Geometric Controller
% geometric backstepping by Taeyoung Lee
function [u] = Naive_Geometric_Control(~, y, trajd, sys_prms)
    ex = y(1:3) - trajd.pos;
    ev = y(4:6) - trajd.vel;

    % compute the desired thrust
    kx = 10;
    kv = 2.5;
    fd = trajd.F - kx * ex - kv * ev;

    % compute the controlled rotation matrix
    e3c = fd / norm(fd);
    e3c_hat = hat(e3c);
    e1c = -e3c_hat^2 * trajd.R(:, 1);
    e1c = e1c / norm(e1c);
    e2c = cross(e3c, e1c);
    Rc = [e1c, e2c, e3c];

    % compute SO(3) error
    R = reshape(y(7:15), 3, 3);
    eR = vee(Rc'*R-R'*Rc) / 2;
    eOmega = y(16:18) - R' * Rc * trajd.Omega;

    % compute the moment and thrust
    kR = 1e2;
    kOmega = 8;
    Omega_hat = hat(y(16:18));
    f = fd' * R(:, 3);
    Mfb = (-kR * eR - kOmega * eOmega);
    Mff = Omega_hat * sys_prms.J * y(16:18) ...
        +sys_prms.J * (R' * Rc * trajd.dOmega - Omega_hat * R' * Rc * trajd.Omega);
    M = Mff + Mfb;
    u = [f; M];
end

%% Sequential CLF-MinNorm Controller without CBF
function [u] = Seq_CLF_QP(~, y, trajd, sys_prms)
    % compute the position and velocity error
    ex = y(1:3) - trajd.pos;
    ev = y(4:6) - trajd.vel;

    % mass property
    m = sys_prms.m;
    J = sys_prms.J;
    g = sys_prms.g;
    e3 = [0; 0; 1];

    % first level of QP : compute the virtual force
    eta1 = 2.5;
    epsilon1 = 2;
    c1 = 6;

    % scale the mass properties to
    V1 = (ev' * ev) / 2 + epsilon1 * (ex' * ev) + c1 * (ex' * ex) / 2;
    LgV1 = (ev + epsilon1 * ex)';
    LfV1 = epsilon1 * (ev' * ev) + c1 * (ev' * ex) - LgV1 * trajd.acc;

    A1 = LgV1;
    b1 = -LfV1 - eta1 * V1;
    H1 = diag([5, 5, 1]);
    f1 = zeros(3, 1);
    optoption_1 = optimset('Display', 'off', 'TolFun', 1e-10); % the first level has more accurate
    accd = quadprog(H1, f1, A1, b1, [], [], [], [], [], optoption_1);
    fd = m * (accd + g * e3);

    % second level of QP : orientation adjustment without considering
    % the external obstacle

    % compute the controlled rotation matrix
    e3c = fd / norm(fd);
    e3c_hat = hat(e3c);
    e1b = -e3c_hat^2 * trajd.R(:, 1);
    e1c = e1b / norm(e1b);
    Rc = [e1c, cross(e3c, e1c), e3c];

    % compute the orientation error
    R = reshape(y(7:15), 3, 3);
    Omega_hat = hat(y(16:18));
    eR = vee(Rc'*R-R'*Rc) / 2;
    eOmega = y(16:18) - R' * Rc * trajd.Omega;
    dR = R * Omega_hat;
    dRc = Rc * hat(trajd.Omega);
    deR = (vee(dRc' * R - R' * dRc) + vee(Rc' * dR - dR' * Rc)) / 2;

    eta2 = 150;
    J_scale = J / min(eig(J));
    epsilon2 = 4;
    c2 = 20;
    V2 = eOmega' * J_scale * eOmega / 2 + epsilon2 * (eR' * eOmega) ...
        +c2 * (eR' * eR) / 2;
    LgV2 = (eOmega' * J_scale + epsilon2 * eR');
    LfV2 = (epsilon2 * eOmega' + c2 * eR') * deR ...
        -LgV2 * (dR' * Rc * trajd.Omega + R' * Rc * trajd.dOmega);

    H2 = diag([1, 1, 1, 4e2]);
    f2 = zeros(4, 1);
    A2 = [LgV2, -1];
    b2 = -LfV2 - eta2 * V2;
    optoption_2 = optimset('Display', 'off', 'TolFun', 1e-5);
    x = quadprog(H2, f2, A2, b2, [], [], [], [], [], optoption_2);
    dOmega = x(1:3);
    M = J * dOmega + Omega_hat * J * y(16:18);
    f = fd' * R(:, 3);
    u = [f; M];
    % disp(['The current position is ' num2str(V1)]);
end

%% Sequential CLF-CBF-MinNorm Controller


function [u] = Seq_CLF_CBF_QP(t, y, trajd, sys_prms)
    % compute the position and velocity error
    ex = y(1:3) - trajd.pos;
    ev = y(4:6) - trajd.vel;

    % extract the state
    Omega = y(16:18);
    Omega_hat = hat(Omega);
    R = reshape(y(7:15), 3, 3);
    dR = R * Omega_hat;

    % mass property
    m = sys_prms.m;
    J = sys_prms.J;
    g = sys_prms.g;
    e3 = [0; 0; 1];
    e3_hat = hat(e3);

    % first level of QP : compute the virtual force
    eta1 = 2.5;
    epsilon1 = 2;
    c1 = 8;

    % scale the mass properties to
    V1 = (ev' * ev) / 2 + epsilon1 * (ex' * ev) + c1 * (ex' * ex) / 2;
    LgV1 = (ev + epsilon1 * ex)';
    LfV1 = epsilon1 * (ev' * ev) + c1 * (ev' * ex) - LgV1 * trajd.acc;

    A1 = LgV1;
    b1 = -LfV1 - eta1 * V1;
    H1 = diag([5, 5, 1]);
    f1 = zeros(3, 1);
    optoption_1 = optimset('Display', 'off', 'TolFun', 1e-6); % the first level has more accurate
    accd = quadprog(H1, f1, A1, b1, [], [], [], [], [], optoption_1);
    fd = (accd + g * e3);

    % second level of QP : combining both CLF and CBF together to
    % take the constraints into account
    % compute the current CBF parameter
    cbf_prms = getCbf(t);

    % compute the controlled rotation matrix
    e3c = fd / norm(fd);
    e3c_hat = hat(e3c);
    e1b = -e3c_hat^2 * trajd.R(:, 1);
    e1c = e1b / norm(e1b);
    Rc = [e1c, cross(e3c, e1c), e3c];
    Fd = max([0, fd' * R(:, 3)]);

    % compute the orientation error
    eR = vee(Rc'*R-R'*Rc) / 2;
    eOmega = y(16:18) - R' * Rc * trajd.Omega;
    dR = R * Omega_hat;
    dRc = Rc * hat(trajd.Omega);
    deR = (vee(dRc' * R - R' * dRc) + vee(Rc' * dR - dR' * Rc)) / 2;

    % CLF construction
    eta2 = 150;
    J_scale = J / min(eig(J));
    epsilon2 = 4;
    c2 = 20;
    V2 = eOmega' * J_scale * eOmega / 2 + epsilon2 * (eR' * eOmega) ...
        +c2 * (eR' * eR) / 2;
    LgV2 = (eOmega' * J_scale + epsilon2 * eR');
    LfV2 = (epsilon2 * eOmega' + c2 * eR') * deR ...
        -LgV2 * (dR' * Rc * trajd.Omega + R' * Rc * trajd.dOmega);

    % CBF construction
    A21 = zeros(cbf_prms.cbfNum, 5);
    b21 = zeros(cbf_prms.cbfNum, 1);
    gamma = 5;

    for j = 1:cbf_prms.cbfNum
        exo = y(1:3) - cbf_prms.xc(:, j);
        evo = y(4:6) - cbf_prms.dxc(:, j);
        d2xo = cbf_prms.d2xc(:, j);
        db = cbf_prms.db(j);
        d2b = cbf_prms.d2b(j);
        s = exo' * R * e3;
        p = exo' * dR * e3 + evo' * R * e3;
        [sigma, dsigma, d2sigma] = angle_barrier(s, cbf_prms.alpha(j), cbf_prms.beta(j));

        % compute the g hat and h hat
        g_hat = exo' * exo - cbf_prms.b(j) - sigma;
        dg_hat = 2 * evo' * exo - db - dsigma * p;
        h_hat = gamma * g_hat + dg_hat;
        xi = (2 * exo - dsigma * R(:, 3))';
        Lgh_hat = [xi * R(:, 3), dsigma * exo' * R * e3_hat];
        Lfh_hat = gamma * dg_hat + 2 * evo' * evo - d2b - d2sigma * p^2 ...
            -dsigma * (2 * evo' * dR * e3 + exo' * R * Omega_hat^2 * e3) ...
            -xi * (d2xo + g * e3) + Lgh_hat(1) * Fd;
        A21(j, 1:4) = -Lgh_hat;
        b21(j) = Lfh_hat + cbf_prms.eta3 * h_hat;
    end

    % set up the quadratic programming
    H2 = diag([25, 1, 1, 1, 200]);
    f2 = zeros(5, 1);
    I = eye(3);
    O = zeros(3, 1);
    A2 = [0, LgV2, -1; ...
        A21; ...
        1, 0, 0, 0, 0; ...
        O, I, O; ...
        O, -I, O];
    b2 = [-LfV2 - eta2 * V2; ...
        b21; ...
        sys_prms.Fmax - Fd; ...
        sys_prms.Mmax; ...
        sys_prms.Mmax];

    optoption_2 = optimset('Display', 'off', 'TolFun', 1e-5);
    x = quadprog(H2, f2, A2, b2, [], [], [], [], [], optoption_2);

    % return the control input
    dOmega = x(2:4);
    M = J * dOmega + Omega_hat * J * Omega;
    f = (x(1) + Fd) * m;
    u = [f; M];

end

%% Convert the current reference stored in structure to
% a 18-dimensional vector
function [y] = struct2vec(trajd)
    y = [trajd.pos; ...
        trajd.vel; ...
        trajd.R(:); ...
        trajd.Omega];
end

%% function of the augmented Barrier function
% two options: arctan and sigmoidal functions
function [sigma, dsigma, d2sigma] = angle_barrier(y, alpha, beta)
    func_type = 2;
    offset = 0.0;
    x = y + offset;
    switch (func_type)
        % ----------------------------------------------------------
        % this function might not be satisfying enough
        % if x >0
        %     sigma = 0;
        %     dsigma = 0;
        %     d2sigma = 0;
        % else
        % sigma = -alpha*x^3*exp(beta*x);
        % dsigma = - 3*alpha*x^2*exp(beta*x) - alpha*beta*x^3*exp(beta*x);
        % d2sigma = 6*alpha*x*exp(-beta*x)...
        %                    - 6*alpha*beta*x^2*exp(-beta*x)...
        %                    + alpha*beta^2*x^3*exp(-beta*x);
        % end

        case 1
            sigma = -(alpha * (exp(beta * x) - 1)) / (exp(beta * x) + 1);
            dsigma = (alpha * beta * exp(beta * x) * (exp(beta * x) - 1)) / (exp(beta * x) + 1)^2 ...
                -(alpha * beta * exp(beta * x)) / (exp(beta * x) + 1);
            d2sigma = (2 * alpha * beta^2 * exp(2 * beta * x)) / (exp(beta * x) + 1)^2 ...
                -(alpha * beta^2 * exp(beta * x)) / (exp(beta * x) + 1) ...
                +(alpha * beta^2 * exp(beta * x) * (exp(beta * x) - 1)) / (exp(beta * x) + 1)^2 ...
                -(2 * alpha * beta^2 * exp(2 * beta * x) * (exp(beta * x) - 1)) / (exp(beta * x) + 1)^3;
        case 2
            sigma = -alpha * atan(x*beta);
            dsigma = -(alpha * beta) / (beta^2 * x^2 + 1);
            d2sigma = (2 * alpha * beta^3 * x) / (beta^2 * x^2 + 1)^2;
    end
end